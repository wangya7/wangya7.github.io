{"meta":{"title":"半農","subtitle":"","description":"","author":"半農","url":"http://bannong.wang","root":"/"},"pages":[],"posts":[{"title":"Dubbo-SPI&自适应的扩展机制","slug":"Dubbo-SPI","date":"2020-12-03T13:51:44.000Z","updated":"2020-12-03T14:06:49.724Z","comments":true,"path":"2020/12/03/Dubbo-SPI/","link":"","permalink":"http://bannong.wang/2020/12/03/Dubbo-SPI/","excerpt":"","text":"META-INF/services 、ServiceLoaderJDK的SPI是一种服务发现机制。SPI将接口的实现类全限定名配置在文件中，由服务加载器读取配置文件，加载实现类，这样可以在运行期间动态的替换实现类。Dubbo实现了增强的SPI机制。Dubbo的SPI相关逻辑被封装在ExtensionLoader中，通过其加载指定的实现类。相比于JDK的路径，Dubbo将配置文件放置在META-INF/dubbo 路径下，同时采用了键值对的形式。 官方文档 SPI和Dubbo的自适应的扩展机制必须放在一起说，分不开的。主要分析 com.alibaba.dubbo.common.extension.ExtensionLoader case 1.ExtensionLoaderTest.robotTest一、初始化type对应ExtensionLoader对象的objectFactory成员变量1ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class); 基础的区别于jdk的SPI加载实践通过 ExtensionLoader.getExtensionLoader(Robot.class); 这行代码就必须走到 new ExtensionLoader(type)。其实这1行代码就是说初始化 ExtensionFactory 的实现，默认是首先加载 ExtensionFactory.class 然后调用了 getAdaptiveExtension()获取自适应拓展 1com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtension 这个方法就是核心需要理解的啦。 调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象 通过反射进行实例化 调用 injectExtension 方法向拓展实例中注入依赖每个步骤里面又细分，尤其是第一步比较精彩！这里面把第1步拿出来说一下。1234567891011121314151617181920212223/** * 1. 调用 getExtensionClasses 获取所有的拓展类 * 2. 检查缓存，若缓存不为空，则返回缓存 * 3. 若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类 * * * 首先从第一个逻辑说起，getExtensionClasses 这个方法用于获取某个接口的所有实现类。比如该方法可以获取 * Protocol 接口的 DubboProtocol、HttpProtocol、InjvmProtocol 等实现类。在获取实现类的过程中， * 如果某个实现类被 Adaptive 注解修饰了，那么该类就会被赋值给 cachedAdaptiveClass 变量。此时，上面步 * 骤中的第二步条件成立（缓存不为空），直接返回 cachedAdaptiveClass 即可。如果所有的实现类均未被 * Adaptive 注解修饰，那么执行第三步逻辑，创建自适应拓展类。 * * @return */private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; // 通过 SPI 获取所有的拓展类 getExtensionClasses(); if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; // 创建自适应拓展类 return cachedAdaptiveClass = createAdaptiveExtensionClass();&#125; 运行代码的时候，会发现 ExtensionFactory 包含两个实现，其中有一个被 @Adaptive 修饰的 AdaptiveExtensionFactory，其实这个在getExtensionClasses内部会初始化赋值给cachedAdaptiveClass，所以return cachedAdaptiveClass;直接返回啦。 二、type对应ExtensionLoader对象获取对应名称的实例对象1Robot optimusPrime = extensionLoader.getExtension(\"optimusPrime\"); 这个就没有啥子说的啦，自己追代码 第1个case就是通过 Class.forName 加载 没啥好说的 dubbo通过自实现的SPI来实现扩展，配置切换。 比如Protocol、Cluster、LoadBalance 等。当某些扩展不想在框架启动时候加载，而希望扩展方法条用的时候，根据运行时参数进行加载。 —— 扩展未加载，难道可以使用扩展的方法？dubbo通过自适应拓展机制很好的解决了，dubbo 会为拓展接口生成具有代理功能的代码，然后通过 javassist 或 jdk 编译这段代码得到Class类，最后再通过反射创建代理类。 @Adaptive用在类上面，基本上都是显现类使用，这个实现类就是这个接口的默认实现（比如上面说的 AdaptiveExtensionFactory）；但是这个注解多数使用在方法上。 case 2.ExtensionLoader_Adaptive_Test.test_getAdaptiveExtension_inject自适应加载测试尤其需要注意 url增加参数的key和value。这需要和创建自适应的代理代码有关系，参考这个方法。 1com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtensionClassCode 其实入口也是上面的createAdaptiveExtension，那么为什么上面没有走到 createAdaptiveExtensionClassCode 方法呢？————是因为上面的 ExtensionFactory 的实现类 AdaptiveExtensionFactory 被 @Adaptive 标注啦。 下面再重温这段代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 1. 调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象 * 2. 通过反射进行实例化 * 3. 调用 injectExtension 方法向拓展实例中注入依赖 * @return */@SuppressWarnings(\"unchecked\")private T createAdaptiveExtension() &#123; try &#123; return injectExtension((T) getAdaptiveExtensionClass().newInstance()); &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e); &#125;&#125;/** * 1. 调用 getExtensionClasses 获取所有的拓展类 * 2. 检查缓存，若缓存不为空，则返回缓存 * 3. 若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类 * * * 首先从第一个逻辑说起，getExtensionClasses 这个方法用于获取某个接口的所有实现类。比如该方法可以获取 * Protocol 接口的 DubboProtocol、HttpProtocol、InjvmProtocol 等实现类。在获取实现类的过程中， * 如果某个实现类被 Adaptive 注解修饰了，那么该类就会被赋值给 cachedAdaptiveClass 变量。此时，上面步 * 骤中的第二步条件成立（缓存不为空），直接返回 cachedAdaptiveClass 即可。如果所有的实现类均未被 * Adaptive 注解修饰，那么执行第三步逻辑，创建自适应拓展类。 * * @return */private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; // 通过 SPI 获取所有的拓展类 getExtensionClasses(); if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; // 创建自适应拓展类 return cachedAdaptiveClass = createAdaptiveExtensionClass();&#125;private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; // 构建自适应拓展代码 String code = createAdaptiveExtensionClassCode(); ClassLoader classLoader = findClassLoader(); // 获取编译器实现类 com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); // 编译代码，生成 Class return compiler.compile(code, classLoader);&#125;/** * 看完这段代码就点杯 喜茶 * 其实很简单 找个案例跑一下 比如 com.alibaba.dubbo.remoting.Transporter 或者 com.alibaba.dubbo.rpc.Protocol * * 默认生成一个代理类的字符串编码 &#123;name&#125;$Adaptive * * @return */private String createAdaptiveExtensionClassCode() &#123; //...省略&#125; case 3.ExtensionLoader_Adaptive_Test.test_getAdaptiveExtension_customizeAdaptiveKey了解加载参数的样式 补充一句，这里就可以看出来URL的作用 相当于数据总线 穿插在各个功能点 通过其绑定绑定配置信息 总结一下 可以借鉴的地方就是 动态生成代理类竟然可以这么玩，有点骚！","categories":[],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://bannong.wang/tags/Dubbo/"},{"name":"Java","slug":"Java","permalink":"http://bannong.wang/tags/Java/"}]},{"title":"个人博客搭建","slug":"Blog","date":"2020-06-18T08:31:44.753Z","updated":"2020-12-03T13:44:37.006Z","comments":true,"path":"2020/06/18/Blog/","link":"","permalink":"http://bannong.wang/2020/06/18/Blog/","excerpt":"","text":"📰本博客采用Hexo，资源直接托管在Github。⚙️关于如果操作，Hexo已经提供文档，自己搜索🔎也行，这面推荐cofess主题作者的一篇文章。 备忘关键操作1234567891011121314# hexo new \"我的博客\"$ hexo n \"我的博客\"# clean$ hexo clean# hexo generate 生成静态页面$ hexo g# hexo server 启动服务预览$ hexo s# hexo deploy 部署$ hexo d","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://bannong.wang/tags/Dubbo/"},{"name":"Java","slug":"Java","permalink":"http://bannong.wang/tags/Java/"}]}